 Quiz App API Server - Database Connection Pool Exhaustion Report

 Executive Summary

 The quiz-app-api-server-app experienced complete service failure due to database connection pool exhaustion. All API endpoints were timing out with "Error: timeout exceeded when 
 trying to connect". The application has been restarted and is now responding, but the underlying issues need to be fixed to prevent recurrence.

 ---
 Root Causes Identified

 1. CRITICAL: Aggressive Connection Timeout (2 seconds)

 Location: /app/src/config/database.js

 const pool = new Pool({
   max: 20,
   idleTimeoutMillis: 30000,
   connectionTimeoutMillis: 2000,  // ⚠️ TOO SHORT!
 });

 Problem: When the connection pool is exhausted, new requests wait only 2 seconds before timing out. Under moderate load, this causes cascading failures.

 Fix Required:
 connectionTimeoutMillis: 20000,  // Increase to 20 seconds

 ---
 2. HIGH: Nested Transaction Anti-Pattern

 Location: /app/src/controllers/authController.js - verifyOTPHandler() function (line ~28)

 Problem:
 - The outer function acquires a database client and starts a transaction (BEGIN)
 - It then calls processReferral() which acquires its OWN separate client and starts ANOTHER transaction
 - During high concurrency, this doubles the connection usage for user registration flows
 - If the outer transaction is long-running, the inner processReferral transaction can hold connections unnecessarily

 Current Flow:
 async function verifyOTPHandler(req, res, next) {
   const client = await pool.connect();  // Connection 1
   try {
     await client.query('BEGIN');

     // ... user creation logic ...

     // This gets ANOTHER connection!
     referralBonus = await processReferral(phone, referral_code);  // Connection 2

     await client.query('COMMIT');
   } catch (err) {
     await client.query('ROLLBACK');
   } finally {
     client.release();
   }
 }

 Fix Required: Refactor processReferral() to accept an existing client parameter instead of creating its own:

 // In referralService.js
 async function processReferral(newUserPhone, referralCode, client = null) {
   const useOwnClient = !client;
   if (useOwnClient) {
     client = await pool.connect();
   }

   try {
     if (useOwnClient) {
       await client.query('BEGIN');
     }

     // ... referral logic ...

     if (useOwnClient) {
       await client.query('COMMIT');
     }

     return result;
   } catch (err) {
     if (useOwnClient) {
       await client.query('ROLLBACK');
     }
     throw err;
   } finally {
     if (useOwnClient) {
       client.release();
     }
   }
 }

 Then pass the existing client from verifyOTPHandler:
 referralBonus = await processReferral(phone, referral_code, client);

 ---
 3. MEDIUM: Small Connection Pool Size

 Current: 20 connections
 PostgreSQL Max: 100 connections

 Problem: With 20 connections and nested transaction patterns, the pool can be exhausted quickly under moderate load.

 Fix Required:
 max: 50,  // Increase from 20 to 50

 ---
 4. HIGH: Docker Health Check Using Authenticated Endpoint

 Location: Docker container configuration

 Current Health Check:
 http://localhost:3000/api/v1/app/online-count

 Problem: This endpoint returns 401 (Unauthorized), causing the container to be permanently marked as "unhealthy" even though the app is working.

 Fix Required:
 1. Create an unauthenticated health endpoint:

 // In app.js or routes
 app.get('/health', (req, res) => {
   res.status(200).json({ status: 'ok' });
 });

 2. Update Docker health check to use /health instead

 ---
 5. MEDIUM: "Idle in Transaction" Connection Leaks

 Observation: Before restart, multiple PostgreSQL connections were stuck in "idle in transaction" state for extended periods.

 Likely Causes:
 - Unhandled exceptions in transaction blocks
 - Missing error handling in edge cases
 - Long-running transactions not being committed/rolled back

 Fix Required: Add statement timeout to prevent runaway transactions:

 const pool = new Pool({
   // ... existing config ...
   statement_timeout: 30000,  // 30 seconds max per statement
   query_timeout: 30000,      // 30 seconds max per query
 });

 ---
 6. LOW: Background Job Connection Usage

 Location: /app/src/services/onlineUsersService.js - startAutoUpdateJob()

 Current: Uses pool.query() directly every 5 minutes

 Observation: This is fine, but ensure it's not contributing to connection pressure

 Recommendation: Already uses pool.query() (not pool.connect()), so no changes needed. Consider adding error handling to prevent crashes.

 ---
 Impact Analysis

 Before Fix:
 - 17+ PostgreSQL connections stuck in "idle in transaction" or "waiting" states
 - All API endpoints failing with connection timeout errors
 - Container marked as unhealthy (5,643 consecutive health check failures)
 - Complete service outage

 After Restart:
 - Application responding normally
 - Only 2 active connections (healthy state)
 - All endpoints operational
 - But underlying issues remain unfixed

 ---
 Recommended Implementation Priority

 P0 (Critical - Fix Immediately):

 1. Increase connectionTimeoutMillis from 2s to 20s
 2. Fix Docker health check to use /health endpoint
 3. Add statement_timeout and query_timeout to pool config

 P1 (High - Fix This Sprint):

 1. Refactor nested transaction in verifyOTPHandler → processReferral
 2. Increase pool max from 20 to 50
 3. Audit all transaction blocks for proper error handling

 P2 (Medium - Fix Next Sprint):

 1. Add connection pool monitoring/metrics
 2. Implement query performance logging
 3. Add database connection health monitoring dashboard

 ---
 Validation Steps After Fixes

 1. Load test with 100 concurrent users registering (triggers the nested transaction issue)
 2. Monitor pg_stat_activity for connection states
 3. Verify health checks pass consistently
 4. Monitor connection pool exhaustion metrics
 5. Test under sustained load for 1+ hour

 ---
 Monitoring Recommendations

 Add these queries to your monitoring:

 -- Check connection pool status
 SELECT count(*), state
 FROM pg_stat_activity
 WHERE datname = 'quizdb'
 GROUP BY state;

 -- Find long-running transactions
 SELECT pid, state, query_start, state_change, query
 FROM pg_stat_activity
 WHERE datname = 'quizdb'
   AND state != 'idle'
   AND state_change < NOW() - INTERVAL '1 minute';

 -- Find idle in transaction connections
 SELECT pid, state, query_start, state_change
 FROM pg_stat_activity
 WHERE state = 'idle in transaction';

 ---
 Files Requiring Changes

 1. /app/src/config/database.js - Pool configuration
 2. /app/src/controllers/authController.js - Nested transaction fix
 3. /app/src/services/referralService.js - Accept client parameter
 4. /app/src/app.js - Add /health endpoint
 5. docker-compose.yml or Dockerfile - Fix health check

 ---
 Status: ✅ Services restarted and operational (temporarily stable)
 Next Steps: Apply the P0 and P1 fixes above to prevent recurrence